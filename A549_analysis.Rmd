---
title: "A549 Lines Analysis"
author: "Covadonga Rodríguez Suárez"
date: "2025-03-03"
output: html_document
---

## 1) Data Preparation and Normalization

```{r, message=FALSE, warning=FALSE}
library(DESeq2)
library(ggplot2)
```

```{r}
counts = read.delim("human_countmatrix_030325.csv", header = TRUE, row.names = 1,sep = ";")
```

```{r}
head(counts)
```


Then, we load the metadata to link the sample name with the groups of the experiment
```{r}
metadata <- read.delim("human_metadatos_030325.csv", header = TRUE, row.names = 1,sep = ";")
metadata
```

```{r}
group = metadata$group
group
```

```{r}
all(colnames(counts) == rownames(metadata))
```

### Build the DESeqDataSet

```{r, warning=FALSE}
dds <- DESeqDataSetFromMatrix(
  countData = counts,
  colData   = metadata,
  design    = ~ group
)
```


### Normalization
```{r}
dds <- estimateSizeFactors(dds)
sizeFactors(dds)
```
```{r}
counts_normalized <- counts(dds, normalized = TRUE)
head(counts_normalized)
```

### Log2 transformation of read counts
```{r}
# Log2 transformation with a pseudocount of 1
counts_log_normalized <- log2(counts_normalized + 1)
```

```{r}
par(mfrow = c(1, 2))

# Boxplot of untransformed normalized counts
boxplot(counts_normalized,
        notch = TRUE,
        las = 2,
        cex.axis = 0.7,
        main = "Untransformed read counts",
        ylab = "read counts")

# Boxplot of log2-transformed normalized counts
boxplot(counts_log_normalized,
        notch = TRUE,
        las = 2,
        cex.axis = 0.7,
        main = "Log2-transformed read counts",
        ylab = "log2(read counts)")

```

## 2) Unsupervised clustering analysis

### Data Transformation

```{r, message=FALSE, warning=FALSE}
library(vsn)
library(hexbin)
```

For real data:
- meanSdPlot() : computes the mean and standard deviation across genes.
- SdPlot$gg : produces a ggplot object, which is then enhanced with a title and custom y-axis label.

```{r}
# Plot for raw normalized counts
SdPlot <- meanSdPlot(counts_normalized, ranks = FALSE, plot = FALSE)
SdPlot$gg + ggtitle("Sequencing depth normalized") +
  ylab("Standard Deviation")
```

```{r}
# Plot for log2-transformed counts (with pseudocount added)
SdPlot_log <- meanSdPlot(counts_log_normalized, ranks = FALSE, plot = FALSE)
SdPlot_log$gg + ggtitle("Sequencing depth normalized log2(read counts)") +
  ylab("Standard Deviation")
```
For simulated data
- We simulate counts with a Poisson distribution using a range of λ (mean) values to illustrate how raw counts exhibit increasing variance with increasing mean.
- The log₂ transformation (with a pseudocount) is applied to the simulated counts, and the resulting plot shows a more homoskedastic (constant variance) distribution. log₂ transformation can stabilize variance in RNA-seq data.
```{r}
# Generate a sequence of lambda values from 10^(-1) to 10^(2)
lambda <- 10^seq(from = -1, to = 2, length.out = 1000)

# Simulate counts using a Poisson distribution: 1000 values for 100 samples
cts <- matrix(rpois(1000 * 100, lambda), ncol = 100)
```

```{r}
# Plot for simulated raw counts
sim_SdPlot <- meanSdPlot(cts, ranks = FALSE, plot = FALSE)
sim_SdPlot$gg + ggtitle("Simulated data: raw counts") +
  ylab("Standard Deviation")
```

```{r}
# Apply log2 transformation (adding a pseudocount of 1)
log.cts.one <- log2(cts + 1)

# Plot for simulated log2-transformed counts
sim_SdPlot_log <- meanSdPlot(log.cts.one, ranks = FALSE, plot = FALSE)
sim_SdPlot_log$gg + ggtitle("Simulated data: log2(read counts)") +
  ylab("Standard Deviation")
```

Transformations with DESeq2
```{r}
# Variance Stabilizing Transformation (VST)
vsd <- vst(dds, blind = FALSE)
head(assay(vsd), 3)
```
```{r}
# Regularized-logarithm Transformation (rlog)
rld <- rlog(dds, blind = FALSE)
head(assay(rld), 3)
```
```{r}
# Compare sample correlations using different data transformations.
par(mfrow = c(2, 2))

# we use only 2 samples as example (AAG3 and ACTC1)

# 1. Raw normalized counts (normalized by sequencing depth)
plot(counts_normalized[, 1:2],
     cex = 0.1,
     main = "Normalized by sequencing depth",
     xlab = "AAG3",
     ylab = "ACTC1")

# 2. Log2-transformed normalized counts (adding a pseudocount of 1)
plot(counts_log_normalized[, 3:4],
     cex = 0.1,
     main = "Normalized log2(read counts)",
     xlab = "AAG3",
     ylab = "ACTC1")

# 3. rlog-transformed counts
rlog_norm_counts <- assay(rld)
plot(rlog_norm_counts[, 3:4],
     cex = 0.1,
     main = "rlog transformed",
     xlab = "AAG3",
     ylab = "ACTC1",
     xlim = c(0, 18),
     ylim = c(0, 18))

# 4. VST-transformed counts
vsd_norm_counts <- assay(vsd)
plot(vsd_norm_counts[, 3:4],
     cex = 0.1,
     main = "VST transformed",
     xlab = "AAG3",
     ylab = "ACTC1",
     xlim = c(0, 18),
     ylim = c(0, 18))

```

### Variance stabilizing transformation

We are going to use both Variance Stabilizing Transformation (VST) and Regularized-log Transformation (rlog)

#### Variance Stabilizing Transformation (VST)

```{r, message=FALSE, warning=FALSE}
library(pheatmap)
library(RColorBrewer)
```

Sample distances with VST
```{r}
sampleDists_vsd <- dist(t(assay(vsd)))  # distance on columns (samples)
sampleDistMatrix_vsd <- as.matrix(sampleDists_vsd)

# Modify row names to show group and replicate (adjust as desired)
rownames(sampleDistMatrix_vsd) <- paste(
  vsd$group,       
  vsd$replicate,  
  sep = "_"
)

colnames(sampleDistMatrix_vsd) <- NULL

# Color palette
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

# Draw heatmap
pheatmap(
  sampleDistMatrix_vsd,
  clustering_distance_rows = sampleDists_vsd,
  clustering_distance_cols = sampleDists_vsd,
  col = colors,
  main = "A549 Sample Distance (VST)"
)
```

PCA Plots with VST

```{r}
# Plot PCA colored by group
plotPCA(vsd, intgroup = "group")
```
```{r}
# also include the replicate
plotPCA(vsd, intgroup = c("group", "replicate"))
```
UMAP on the top 10 principal components  using the principal components of your VST-transformed data
```{r, message=FALSE, warning=FALSE}
library(umap)

# Perform PCA on VST-transformed data (samples as rows)

pca_res_vsd <- prcomp(t(assay(vsd)), scale. = TRUE)

# Run UMAP on the top 10 principal components (adjust n_neighbors as needed)
umap_res_vsd <- umap(pca_res_vsd$x[, 1:10], n_neighbors = 5)

# Extract the layout component from the UMAP result and convert it to a data frame
umap_df_vsd <- as.data.frame(umap_res_vsd$layout)
colnames(umap_df_vsd) <- c("UMAP1", "UMAP2")

# Add the sample group information from your vsd object
umap_df_vsd$group <- vsd$group

# Create UMAP plot using ggplot2
p_vsd <- ggplot(umap_df_vsd, aes(x = UMAP1, y = UMAP2, color = group)) +
  geom_point(size = 4, shape = 19, alpha = 0.8) +
  labs(
    title = "A549 UMAP (VST-transformed counts)",
    x = "UMAP Dimension 1",
    y = "UMAP Dimension 2",
    color = "Sample Group"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey85"),
    panel.grid.minor = element_blank()
  )

print(p_vsd)
```



#### Regularized-log Transformation (rlog)

Sample distances with rlog
```{r}
sampleDists_rld <- dist(t(assay(rld)))
sampleDistMatrix_rld <- as.matrix(sampleDists_rld)

# Modify row names similarly
rownames(sampleDistMatrix_rld) <- paste(
  rld$group,
  rld$replicate,
  sep = "_"
)

colnames(sampleDistMatrix_rld) <- NULL

# Use the same color palette
pheatmap(
  sampleDistMatrix_rld,
  clustering_distance_rows = sampleDists_rld,
  clustering_distance_cols = sampleDists_rld,
  col = colors,
  main = "A549 Sample Distance (rlog)"
)
```
PCA Plots with rlog
```{r}
plotPCA(rld, intgroup = "group")
```

```{r}
plotPCA(rld, intgroup = c("group", "replicate"))
```
UMAP on the top 10 principal components  using the principal components of rlog-transformed data
```{r}

# Perform PCA on rlog-transformed data (samples as rows)
pca_res_rlog <- prcomp(t(assay(rld)), scale. = TRUE)

# Run UMAP on the top 10 principal components (adjust n_neighbors as needed)
umap_res_rlog <- umap(pca_res_rlog$x[, 1:10], n_neighbors = 5)

# Extract the layout component from the umap result and convert it to a data frame
umap_df_rlog <- as.data.frame(umap_res_rlog$layout)
colnames(umap_df_rlog) <- c("UMAP1", "UMAP2")

# Add the sample group information from your rld object
umap_df_rlog$group <- rld$group

# Create a professional UMAP plot using ggplot2
p_rlog <- ggplot(umap_df_rlog, aes(x = UMAP1, y = UMAP2, color = group)) +
  geom_point(size = 4, shape = 19, alpha = 0.8) +
  labs(
    title = "UMAP Projection from PCA of rlog-transformed counts",
    x = "UMAP Dimension 1",
    y = "UMAP Dimension 2",
    color = "Sample Group"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey85"),
    panel.grid.minor = element_blank()
  )

# Display the plot
print(p_rlog)
```


## 3) Differential gene expression analysis (DGEA)

Run the DESeq2 pipeline

This step:
  1) estimates size factors 
  2) estimates dispersion parameters
  3) fits the negative binomial GLM
  4) performs the Wald test (or LRT if specified)
  
```{r, message=FALSE, warning=FALSE}
dds$group <- relevel(dds$group, ref = "P")
dds_DGE <- DESeq(dds)
```

Check the mean-dispersion relationship using plot of dispersion vs. mean of normalized counts, with fitted and final estimates.
```{r}
par(mfrow = c(1, 1))
plotDispEsts(dds_DGE)
```

Extract results: compare all lines against the parental one calculating the log2 fold change of AG relative to P (i.e., AG ÷ P). Likewise for CTC vs. P and L vs. P.

```{r}
levels(dds$group)
```


1) AG vs P
```{r}
dds_DGE_results_AG_vs_P <- results(dds_DGE, contrast = c("group","AG","P"))
head(dds_DGE_results_AG_vs_P)
summary(dds_DGE_results_AG_vs_P)
```

```{r, message=FALSE, warning=FALSE}
# Subset significant genes for AG vs P
resSig_AG_vs_P <- subset(dds_DGE_results_AG_vs_P,
                         padj < 0.05 &
                         abs(log2FoldChange) > 2)


resSig_AG_vs_P <- resSig_AG_vs_P[
  order(resSig_AG_vs_P$padj,
        -resSig_AG_vs_P$log2FoldChange),]

# Add a 'symbol' column to your significant results using the ENSEMBL IDs
library(AnnotationDbi)
library(org.Hs.eg.db)

resSig_AG_vs_P$symbol <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_AG_vs_P),
                                column = "SYMBOL",
                                keytype = "ENSEMBL",
                                multiVals = "first")

head(resSig_AG_vs_P)
```

```{r}
# Strongest downregulated genes (lowest log2 fold change)
head(resSig_AG_vs_P[order(resSig_AG_vs_P$log2FoldChange), ])
```

```{r}
# Strongest upregulated genes (highest log2 fold change)
head(resSig_AG_vs_P[order(resSig_AG_vs_P$log2FoldChange, decreasing = TRUE), ])
```

```{r}
# Export the significant results to a file
# write.table(resSig_AG_vs_P, file = "A549_padj05_logFC2_Significant_Results_AG_vs_P.txt", sep = "\t", quote = FALSE, row.names = TRUE)
```


2) CTC vs P
```{r}
dds_DGE_results_CTC_vs_P <- results(dds_DGE, contrast = c("group","CTC","P"))
head(dds_DGE_results_CTC_vs_P)
summary(dds_DGE_results_CTC_vs_P)
```
```{r}
# Subset significant genes for CTC vs P
resSig_CTC_vs_P <- subset(dds_DGE_results_CTC_vs_P,
                          padj < 0.05 &
                          abs(log2FoldChange) > 2)

resSig_CTC_vs_P <- resSig_CTC_vs_P[
  order(resSig_CTC_vs_P$padj,
        -resSig_CTC_vs_P$log2FoldChange),
]

resSig_CTC_vs_P$symbol <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_CTC_vs_P),
                                column = "SYMBOL",
                                keytype = "ENSEMBL",
                                multiVals = "first")

head(resSig_CTC_vs_P)
```

```{r}
# Strongest downregulated genes (lowest log2 fold change)
head(resSig_CTC_vs_P[order(resSig_CTC_vs_P$log2FoldChange), ])
```

```{r}
# Strongest upregulated genes (highest log2 fold change)
head(resSig_CTC_vs_P[order(resSig_CTC_vs_P$log2FoldChange, decreasing = TRUE), ])
```

```{r}
# Export the significant results to a file
# write.table(resSig_CTC_vs_P, file = "A549_padj01_logFC2_Significant_Results_CTC_vs_P.txt", sep = "\t", quote = FALSE, row.names = TRUE)
```


3) L vs P
```{r}
dds_DGE_results_L_vs_P <- results(dds_DGE, contrast = c("group","L","P"))
head(dds_DGE_results_L_vs_P)
summary(dds_DGE_results_L_vs_P)
```

```{r}
# Subset significant genes for L vs P
resSig_L_vs_P <- subset(dds_DGE_results_L_vs_P,
                        padj < 0.05 &
                        abs(log2FoldChange) > 2)

resSig_L_vs_P <- resSig_L_vs_P[order(resSig_L_vs_P$padj,
                                     -resSig_L_vs_P$log2FoldChange), ]

resSig_L_vs_P$symbol <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_L_vs_P),
                                column = "SYMBOL",
                                keytype = "ENSEMBL",
                                multiVals = "first")

head(resSig_L_vs_P)
```

```{r}
# Strongest downregulated genes (lowest log2 fold change)
head(resSig_L_vs_P[order(resSig_L_vs_P$log2FoldChange), ])
```

```{r}
# Strongest upregulated genes (highest log2 fold change)
head(resSig_L_vs_P[order(resSig_L_vs_P$log2FoldChange, decreasing = TRUE), ])
```

```{r}
# Export the significant results to a file
# write.table(resSig_L_vs_P, file = "A549_padj01_logFC2_Significant_Results_L_vs_P.txt", sep = "\t", quote = FALSE, row.names = TRUE)
```

## 4) Exploratory plots

Plot Counts for an Individual Gene (in case we want to explore any paricular gene of interest and visualize raw counts normalized by DESeq2 for it)
```{r}
# plotCounts(dds, gene = "ENSG0000012345", intgroup = "group")
```

Histogram of p-values for each comparison
- An enrichment near zero typically indicates many significantly differentially expressed genes
```{r}
par(mfrow = c(1, 3))

hist(dds_DGE_results_AG_vs_P$pvalue,
     col = "blue",
     border = "white",
     xlab = "",
     ylab = "Frequency",
     breaks = seq(0, 1, 0.05),
     main = "Histogram of p-values (AG vs. P)")

hist(dds_DGE_results_CTC_vs_P$pvalue,
     col = "blue",
     border = "white",
     xlab = "",
     ylab = "Frequency",
     breaks = seq(0, 1, 0.05),
     main = "Histogram of p-values (CTC vs. P)")

hist(dds_DGE_results_L_vs_P$pvalue,
     col = "blue",
     border = "white",
     xlab = "",
     ylab = "Frequency",
     breaks = seq(0, 1, 0.05),
     main = "Histogram of p-values (L vs. P)")

```
MA Plot to visualize the log2 fold changes (M) versus the average expression (A)

```{r, message=FALSE, warning=FALSE}
library(apeglm)

# 1) AG vs P
# Basic MA plot
plotMA(dds_DGE_results_AG_vs_P, alpha = 0.05,
       main = "AG vs. P (Basic MA plot)",
       ylim = c(-5, 5))
# Shrunken MA plot
res_shrunk_AG_vs_P <- lfcShrink(dds_DGE, coef = "group_AG_vs_P", type = "apeglm")
plotMA(res_shrunk_AG_vs_P, alpha = 0.05,
       main = "AG vs. P (Shrunk MA Plot)",
       ylim = c(-5, 5))

# 2) CTC vs P
plotMA(dds_DGE_results_CTC_vs_P, alpha = 0.05,
       main = "CTC vs. P (Basic)",
       ylim = c(-5, 5))
res_shrunk_CTC_vs_P <- lfcShrink(dds_DGE, coef = "group_CTC_vs_P", type = "apeglm")
plotMA(res_shrunk_CTC_vs_P, alpha = 0.05,
       main = "CTC vs. P (Shrunk)",
       ylim = c(-5, 5))

# 3) L vs P
plotMA(dds_DGE_results_L_vs_P, alpha = 0.05,
       main = "L vs. P (Basic)",
       ylim = c(-5, 5))
res_shrunk_L_vs_P <- lfcShrink(dds_DGE, coef = "group_L_vs_P", type = "apeglm")
plotMA(res_shrunk_L_vs_P, alpha = 0.05,
       main = "L vs. P (Shrunk)",
       ylim = c(-5, 5))
```
Volcano Plots

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(ggrepel)
library(org.Hs.eg.db)
```

1) AG vs P

```{r, warning=FALSE}

# Convert DESeq2 results to a data frame
results_order_AG <- as.data.frame(dds_DGE_results_AG_vs_P)

# Add the symbol column (mapping from ENSEMBL to SYMBOL)
results_order_AG$symbol <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(results_order_AG),  # ENSEMBL gene IDs
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
)

# Replace padj == 0 with a small number to avoid -Inf in log scale
results_order_AG$padj[results_order_AG$padj == 0] <- 1e-300

# Create a -log10(padj) column
results_order_AG$negLog10Padj <- -log10(results_order_AG$padj)


# Define Up, Down, or Not Sig

results_order_AG$Significance <- "Not Sig"
results_order_AG$Significance[
  results_order_AG$padj < 0.05 & results_order_AG$log2FoldChange > 0.38
] <- "Up"
results_order_AG$Significance[
  results_order_AG$padj < 0.05 & results_order_AG$log2FoldChange < -0.38
] <- "Down"


# Create the Volcano Plot

p_AG <- ggplot(results_order_AG, aes(x = log2FoldChange, y = negLog10Padj)) +
  geom_point(aes(color = Significance), alpha = 0.8, size = 2) +
  scale_color_manual(
    values = c("Down" = "#377EB8", "Not Sig" = "grey70", "Up" = "firebrick")
  ) +
  labs(
    title = "A549 AdrenalGland vs. Parental",
    x = expression(log[2]~fold~change),
    y = expression(-log[10]~(padj))
  ) +
  theme_minimal(base_size = 14) +  # or theme_bw(base_size = 14)
  theme(
    plot.title       = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank(),
    legend.title     = element_blank()
  )

# Add dashed lines for log2FC = ±1 and padj = 0.05
p_AG <- p_AG +
  geom_vline(xintercept = c(-0.38, 0.38), color = "blue", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "blue", linetype = "dashed")


# 4) Label the Top Genes
# Pick genes with padj < 0.01 and |log2FoldChange| > 2
topGenes_AG <- subset(results_order_AG, padj < 0.01 & abs(log2FoldChange) > 2)
# Sort by smallest padj
topGenes_AG <- topGenes_AG[order(topGenes_AG$padj), ]
# Take the top 20
topGenes20_AG <- head(topGenes_AG, 20)

p_AG <- p_AG +
  geom_label_repel(
    data = topGenes20_AG,
    aes(label = symbol),
    size = 3,
    color = "black",
    fill = "white",
    box.padding = 0.65,       
    point.padding = 0.3,     
    force = 15,               
    max.overlaps = Inf,      
    segment.color = "black"
  )

# Print the final plot
print(p_AG)
```

2) CTC vs P
```{r, warning=FALSE}

# Convert your DESeq2 results for CTC vs. P into a data frame
results_order_CTC <- as.data.frame(dds_DGE_results_CTC_vs_P)

# Map ENSEMBL IDs to SYMBOLs
results_order_CTC$symbol <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(results_order_CTC),  # ENSEMBL gene IDs
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
)

# Replace padj == 0 with a small number to avoid -Inf in log scale
results_order_CTC$padj[results_order_CTC$padj == 0] <- 1e-300

# Create a -log10(padj) column
results_order_CTC$negLog10Padj <- -log10(results_order_CTC$padj)


# Define Up, Down, or Not Sig

results_order_CTC$Significance <- "Not Sig"
results_order_CTC$Significance[
  results_order_CTC$padj < 0.05 & results_order_CTC$log2FoldChange > 0.38
] <- "Up"
results_order_CTC$Significance[
  results_order_CTC$padj < 0.05 & results_order_CTC$log2FoldChange < -0.38
] <- "Down"


# Create the Volcano Plot

p_CTC <- ggplot(results_order_CTC, aes(x = log2FoldChange, y = negLog10Padj)) +
  geom_point(aes(color = Significance), alpha = 0.8, size = 2) +
  scale_color_manual(
    values = c("Down" = "#377EB8", "Not Sig" = "grey70", "Up" = "firebrick")
  ) +
  labs(
    title = "A549 CTC vs. Parental",
    x = expression(log[2]~fold~change),
    y = expression(-log[10]~(padj))
  ) +
  theme_minimal(base_size = 14) + 
  theme(
    plot.title       = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank(),
    legend.title     = element_blank()
  )

# Add dashed lines for log2FC = ±1 and padj = 0.05
p_CTC <- p_CTC +
  geom_vline(xintercept = c(-0.38, 0.38), color = "blue", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "blue", linetype = "dashed")


# Label the Top Genes

# pick genes with padj < 0.01 and |log2FoldChange| > 2
topGenes_CTC <- subset(results_order_CTC, padj < 0.01 & abs(log2FoldChange) > 2)
# Sort by smallest padj
topGenes_CTC <- topGenes_CTC[order(topGenes_CTC$padj), ]
# Take the top 20
topGenes20_CTC <- head(topGenes_CTC, 20)

p_CTC <- p_CTC +
  geom_label_repel(
    data = topGenes20_CTC,
    aes(label = symbol),
    size = 3,
    color = "black",
    fill = "white",
    box.padding = 0.6,       
    point.padding = 0.3,     
    force = 15,               
    max.overlaps = Inf,      
    segment.color = "black"
  )

# Print the final plot
print(p_CTC)
```
3) Bone vs P
```{r, warning=FALSE}

results_order_L <- as.data.frame(dds_DGE_results_L_vs_P)

results_order_L$symbol <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(results_order_L),  # ENSEMBL gene IDs
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
)


results_order_L$padj[results_order_L$padj == 0] <- 1e-300


results_order_L$negLog10Padj <- -log10(results_order_L$padj)


results_order_L$Significance <- "Not Sig"
results_order_L$Significance[
  results_order_L$padj < 0.05 & results_order_L$log2FoldChange > 0.38
] <- "Up"
results_order_L$Significance[
  results_order_L$padj < 0.05 & results_order_L$log2FoldChange < -0.38
] <- "Down"


p_L <- ggplot(results_order_L, aes(x = log2FoldChange, y = negLog10Padj)) +
  geom_point(aes(color = Significance), alpha = 0.8, size = 2) +
  scale_color_manual(
    values = c("Down" = "#377EB8", "Not Sig" = "grey70", "Up" = "firebrick")
  ) +
  labs(
    title = "A549 Bone vs. Parental",
    x = expression(log[2]~fold~change),
    y = expression(-log[10]~(padj))
  ) +
  theme_minimal(base_size = 14) + 
  theme(
    plot.title       = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank(),
    legend.title     = element_blank()
  )


p_L <- p_L +
  geom_vline(xintercept = c(-0.38, 0.38), color = "blue", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "blue", linetype = "dashed")


topGenes_L <- subset(results_order_L, padj < 0.01 & abs(log2FoldChange) > 2)
topGenes_L <- topGenes_L[order(topGenes_L$padj), ]
topGenes20_L <- head(topGenes_L, 20)

p_L <- p_L +
  geom_label_repel(
    data = topGenes20_L,
    aes(label = symbol),
    size = 3,
    color = "black",
    fill = "white",
    box.padding = 0.65,       
    point.padding = 0.3,     
    force = 15,               
    max.overlaps = Inf,      
    segment.color = "black"
  )


print(p_L)
```


Heatmap of the top 20 most variable genes from variance-stabilized data

```{r, message=FALSE, warning=FALSE}
library(pheatmap)
library(RColorBrewer)
library(matrixStats)
```

```{r}
# 1. Identify the top 20 most variable genes by variance
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 20)

# 2. Extract the ENSEMBL IDs for these top genes
topVar_ensembl_ids <- rownames(assay(vsd))[topVarGenes]

# 3. Subset the VST matrix
mat <- assay(vsd)[topVar_ensembl_ids, ]

# 4. Convert ENSEMBL IDs to gene symbols
symbol_map <- mapIds(
  org.Hs.eg.db,
  keys = topVar_ensembl_ids,
  column = "SYMBOL",
  keytype = "ENSEMBL",
  multiVals = "first"
)

# 5. Rename rows of 'mat' with the gene symbols
rownames(mat) <- symbol_map

# 6. Center each row to emphasize relative expression differences
mat <- mat - rowMeans(mat)

# 7. Create a data frame for column annotation (only 'group')
annotation_col <- as.data.frame(colData(vsd)[, "group", drop = FALSE])

# 8. Choose a color palette
my_colors <- colorRampPalette(rev(brewer.pal(9, "RdBu")))(255)


# 9. Decide the order of the samples
desired_order <- c("AP1","AP2","AP3", # P
                   "ACTC1","ACTC2","ACTC3", # CTC
                   "AAG1","AAG2","AAG3", # AG
                   "AL1","AL2","AL3")     # L

mat2 <- mat[, desired_order]

annotation_col2 <- annotation_col[desired_order, , drop=FALSE]

# 10. Draw the heatmap
pheatmap(
  mat2,
  annotation_col = annotation_col2,
  color = my_colors,
  show_rownames = TRUE,
  cluster_cols = FALSE,       # <—— no re‐clustering of columns
  main = "A549: Top 20 Most Variable Genes"
)
```
All-in-one 
```{r}
make_heatmap <- function(dds_res, contrast_name, keep_groups, desired_order){
  res    <- subset(dds_res, padj<.05)
  res    <- res[order(res$padj), ]
  top20  <- head(res,20)
  top20$symbol <- mapIds(org.Hs.eg.db,
                         keys    = rownames(top20),
                         column  = "SYMBOL",
                         keytype = "ENSEMBL",
                         multiVals= "first")
  mat    <- assay(vsd)[rownames(top20),]
  rownames(mat) <- top20$symbol
  keep   <- rownames(colData(vsd))[colData(vsd)$group %in% keep_groups]
  mat2   <- mat[,keep] - rowMeans(mat[,keep])
  anno   <- data.frame(group = colData(vsd)[keep,"group"],
                       row.names=keep)
  mat2   <- mat2[,desired_order]
  anno   <- anno[desired_order,,drop=FALSE]
  pheatmap(mat2,
           annotation_col = anno,
           color          = my_colors,
           cluster_cols   = FALSE,
           main           = paste("A549", contrast_name, ": Top 20 DEGs"))
}

make_heatmap(dds_DGE_results_AG_vs_P, "AG vs P", c("AG","P"),
             c("AP1","AP2","AP3","AAG1","AAG2","AAG3"))
make_heatmap(dds_DGE_results_L_vs_P,  "L  vs P", c("L","P"),
             c("AP1","AP2","AP3","AL1","AL2","AL3"))
make_heatmap(dds_DGE_results_CTC_vs_P,"CTC vs P",c("CTC","P"),
             c("AP1","AP2","AP3","ACTC1","ACTC2","ACTC3"))
```


```{r}
library(GenomicAlignments)   # para mapIds
library(org.Hs.eg.db)
library(AnnotationDbi)
library(pheatmap)
library(RColorBrewer)
```

Individual HeatMap for AG vs P
```{r}
# 1. Subset significant genes and sort by padj
resSig <- subset(dds_DGE_results_AG_vs_P, padj < 0.05)
resSig <- resSig[order(resSig$padj), ]

# 2. Take the top 20
top20 <- head(resSig, 20)

# 3. Map to gene symbols
top20$symbol <- mapIds(org.Hs.eg.db,
                       keys = rownames(top20),
                       column = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first")

# 4. Pull out the VST counts for those 20 genes
vsd_mat <- assay(vsd)
mat <- vsd_mat[rownames(top20), ]

# 5. Replace rownames with symbols
rownames(mat) <- top20$symbol

# 6. Subset to only Parental (P) and AdrenalGland (AG) samples
meta <- as.data.frame(colData(vsd))
keep <- rownames(meta)[meta$group %in% c("P","AG")]
mat2 <- mat[, keep]

# 7. Center the rows (optional but typical for heatmaps)
mat2 <- mat2 - rowMeans(mat2)

# 8. Build your column‐annotation df
annotation_col <- data.frame(
  group = meta[keep,"group"],
  row.names = keep
)

# 9. Define your desired sample order
desired_order <- c(
  "AP1","AP2","AP3",      
  "AAG1","AAG2","AAG3"     
)

# 10. Re‐order both matrix and annotation
mat2 <- mat2[, desired_order]
annotation_col <- annotation_col[desired_order, , drop=FALSE]

# 11. Choose colors
my_colors <- colorRampPalette(rev(brewer.pal(9, "RdBu")))(255)

# 12. Draw the heatmap, no column clustering
pheatmap(
  mat2,
  annotation_col    = annotation_col,
  color             = my_colors,
  cluster_cols = FALSE,     
  show_rownames = TRUE,
  main = "A549 AdrenalGland vs Parental: Top 20 DEGs"
)
```

Individual HeatMap for L vs P
```{r}
# 1. Subset significant genes and sort by padj (L vs P)
resSig <- subset(dds_DGE_results_L_vs_P, padj < 0.05)
resSig <- resSig[order(resSig$padj), ]

# 2. Grab the top 20
top20 <- head(resSig, 20)

# 3. Map ENSEMBL → SYMBOL
top20$symbol <- mapIds(org.Hs.eg.db,
                       keys = rownames(top20),
                       column = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first")

# 4. Extract the VST counts for those genes
vsd_mat <- assay(vsd)
mat <- vsd_mat[rownames(top20), ]

# 5. Rename rows to gene symbols
rownames(mat) <- top20$symbol

# 6. Keep only P and L samples
meta <- as.data.frame(colData(vsd))
keep <- rownames(meta)[meta$group %in% c("P","L")]
mat2 <- mat[, keep]

# 7. Center rows (optional)
mat2 <- mat2 - rowMeans(mat2)

# 8. Build the annotation df
annotation_col <- data.frame(
  group = meta[keep, "group"],
  row.names = keep
)

# 9. Define your desired sample order
desired_order <- c("AP1","AP2","AP3",
                   "AL1","AL2","AL3")

# 10. Reorder both matrix and annotation
mat2 <- mat2[, desired_order]
annotation_col <- annotation_col[desired_order, , drop = FALSE]

# 11. Pick your colors
my_colors <- colorRampPalette(rev(brewer.pal(9, "RdBu")))(255)

# 12. Draw the heatmap, no column‐clustering
pheatmap(
  mat2,
  annotation_col = annotation_col,
  color = my_colors,
  cluster_cols = FALSE,          
  show_rownames = TRUE,
  main = "A549 Limb vs Parental: Top 20 DEGs"
)
```
Individual HeatMap for CTC vs P
```{r, message=FALSE, warning=FALSE}
# 1. Subset significant genes and sort by padj (CTC vs P)
resSig <- subset(dds_DGE_results_CTC_vs_P, padj < 0.05)
resSig <- resSig[order(resSig$padj), ]

# 2. Take the top 20
top20 <- head(resSig, 20)

# 3. Map ENSEMBL → SYMBOL
top20$symbol <- mapIds(org.Hs.eg.db,
                       keys    = rownames(top20),
                       column  = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first")

# 4. Extract VST counts for those genes
vsd_mat <- assay(vsd)
mat <- vsd_mat[rownames(top20), ]

# 5. Rename rows to gene symbols
rownames(mat) <- top20$symbol

# 6. Keep only Parental (P) and CTC samples
meta <- as.data.frame(colData(vsd))
keep <- rownames(meta)[meta$group %in% c("P","CTC")]
mat2 <- mat[, keep]

# 7. Center rows (optional)
mat2 <- mat2 - rowMeans(mat2)

# 8. Build your column‐annotation df
annotation_col <- data.frame(
  group = meta[keep, "group"],
  row.names = keep
)

# 9. Define your desired sample order
desired_order <- c(
  "AP1","AP2","AP3",      # Parental
  "ACTC1","ACTC2","ACTC3" # CTC
)

# 10. Reorder both matrix and annotation
mat2 <- mat2[, desired_order]
annotation_col <- annotation_col[desired_order, , drop=FALSE]

# 11. Pick your color palette
my_colors <- colorRampPalette(rev(brewer.pal(9, "RdBu")))(255)

# 12. Draw the heatmap without column clustering
pheatmap(
  mat2,
  annotation_col = annotation_col,
  color          = my_colors,
  cluster_cols   = FALSE,     # preserves your desired_order
  show_rownames  = TRUE,
  main           = "A549 CTC vs Parental: Top 20 DEGs"
)
```

## 5) Annotate Results

```{r, message=FALSE, warning=FALSE}
library(AnnotationDbi)
library(org.Hs.eg.db)
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(cowplot)
library(dplyr)
library(ggrepel)
```


1) For CTC vs P
```{r}
# Annotate resSig_CTC_vs_P with gene symbol, gene name, and ENTREZ ID
resSig_CTC_vs_P$symbol <- mapIds(org.Hs.eg.db,
                                 keys = rownames(resSig_CTC_vs_P),
                                 column = "SYMBOL",
                                 keytype = "ENSEMBL",
                                 multiVals = "first")

resSig_CTC_vs_P$genename <- mapIds(org.Hs.eg.db,
                                   keys = rownames(resSig_CTC_vs_P),
                                   column = "GENENAME",
                                   keytype = "ENSEMBL",
                                   multiVals = "first")

resSig_CTC_vs_P$entrez <- mapIds(org.Hs.eg.db,
                                 keys = rownames(resSig_CTC_vs_P),
                                 column = "ENTREZID",
                                 keytype = "ENSEMBL",
                                 multiVals = "first")

# Build a vector of ENTREZ IDs (remove any NAs)
geneList_CTC <- na.omit(resSig_CTC_vs_P$entrez)

# Perform GO over-representation analysis 
ego_BP_CTC <- enrichGO(
  gene          = geneList_CTC,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",           # change here for BP
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# For Molecular Function (MF)
ego_MF_CTC <- enrichGO(
  gene          = geneList_CTC,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "MF",           # change here for MF
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

barplot(ego_BP_CTC, showCategory = 20, title = "GO BP Enrichment (A549 CTC vs P)")
dotplot(ego_MF_CTC, showCategory = 20, title = "GO MF Enrichment (A549 CTC vs P)")
```

```{r, message=FALSE, warning=FALSE}

## Enrichment maps

# 1) Convert enrichGO results to a "readable" object, so gene IDs become symbols

ego_CC_CTC <- enrichGO(
  gene          = geneList_CTC,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_C <- setReadable(ego_CC_CTC, 'org.Hs.eg.db', 'ENTREZID')

# 2) Build a fold-change vector for your genes
geneList_C <- resSig_CTC_vs_P$log2FoldChange
names(geneList_C) <- as.character(resSig_CTC_vs_P$entrez)
geneList_C <- sort(geneList_C, decreasing = TRUE)

p1_C <- cnetplot(
  edox_C,
  foldChange   = geneList_C,
  categorySize = "pvalue",
  circular     = TRUE,      # <-- ring layout
  colorEdge    = TRUE       # <-- edges are colored by category
  # showCategory = 5        # optionally limit the number of categories displayed
  # node_label  = "gene"    # optionally label gene nodes with symbols
) + ggtitle("Gene Concept Network (A549 CTC vs P)")

# 4) Create an enrichment map
edox_C <- pairwise_termsim(edox_C)
p2_C <- emapplot(edox_C, layout = "kk") +
  ggtitle("Enrichment Map (CTC vs P)")

# 5) Combine the cnetplot and emapplot side by side
pdf("A549_CTCvsP_Enrichment_Networks.pdf", width=25, height=10)
cowplot::plot_grid(p1_C, p2_C, ncol=2, labels=LETTERS[1:3], rel_widths=c(.8, .8, 1.2))
dev.off()
```
```{r}
# Filter resSig_CTC_vs_P for abs(log2FoldChange) > 2
resSig_CTC_vs_P_filtered <- resSig_CTC_vs_P[abs(resSig_CTC_vs_P$log2FoldChange) > 2, ]

# Build filtered fold-change vector
geneList_C_filtered <- resSig_CTC_vs_P_filtered$log2FoldChange
names(geneList_C_filtered) <- as.character(resSig_CTC_vs_P_filtered$entrez)
geneList_C_filtered <- sort(geneList_C_filtered, decreasing = TRUE)

# Run enrichGO using filtered gene list
ego_CC_CTC_filtered <- enrichGO(
  gene          = names(geneList_C_filtered),
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_C_filtered <- setReadable(ego_CC_CTC_filtered, 'org.Hs.eg.db', 'ENTREZID')

# Create the cnetplot
p1_C_filtered <- cnetplot(
  edox_C_filtered,
  foldChange   = geneList_C_filtered,
  categorySize = "pvalue",
  circular     = TRUE,
  colorEdge    = TRUE
) + ggtitle("Gene Concept Network (Filtered |CTC vs P| > 2)")

# Create the enrichment map
edox_C_filtered <- pairwise_termsim(edox_C_filtered)
p2_C_filtered <- emapplot(edox_C_filtered, layout = "kk") +
  ggtitle("Enrichment Map (Filtered |CTC vs P| > 2)")

# Combine plots into PDF
pdf("A549_CTCvsP_Enrichment_Networks_filtered.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_C_filtered, p2_C_filtered, ncol = 2, labels = LETTERS[1:3], rel_widths = c(.8, .8, 1.2))
dev.off()
```


2) For L vs P
```{r}
# Annotate resSig_L_vs_P with gene symbol, gene name, and ENTREZ ID
resSig_L_vs_P$symbol <- mapIds(org.Hs.eg.db,
                               keys = rownames(resSig_L_vs_P),
                               column = "SYMBOL",
                               keytype = "ENSEMBL",
                               multiVals = "first")

resSig_L_vs_P$genename <- mapIds(org.Hs.eg.db,
                                 keys = rownames(resSig_L_vs_P),
                                 column = "GENENAME",
                                 keytype = "ENSEMBL",
                                 multiVals = "first")

resSig_L_vs_P$entrez <- mapIds(org.Hs.eg.db,
                               keys = rownames(resSig_L_vs_P),
                               column = "ENTREZID",
                               keytype = "ENSEMBL",
                               multiVals = "first")

# Build a vector of ENTREZ IDs (remove any NAs)
geneList_L <- na.omit(resSig_L_vs_P$entrez)

# Perform GO over-representation analysis (can also be for Cellular Compartiment)
# For Biological Process (BP)
ego_BP_L <- enrichGO(
  gene          = geneList_L,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",           # change here for BP
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# For Molecular Function (MF)
ego_MF_L <- enrichGO(
  gene          = geneList_L,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "MF",           # change here for MF
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

barplot(ego_BP_L, showCategory = 20, title = "GO BP Enrichment (A549 L vs P)")
dotplot(ego_MF_L, showCategory = 20, title = "GO MF Enrichment (A549 L vs P)")
```
```{r, message=FALSE, warning=FALSE}
## Enrichment maps for L vs P

# 1) Convert enrichGO results (ego_L) to a "readable" object, so gene IDs become symbols

ego_CC_L <- enrichGO(
  gene          = geneList_L,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_L <- setReadable(ego_CC_L, 'org.Hs.eg.db', 'ENTREZID')

# 2) Build a fold-change vector for your genes using the L vs P significant results
geneList_L <- resSig_L_vs_P$log2FoldChange
names(geneList_L) <- as.character(resSig_L_vs_P$entrez)
geneList_L <- sort(geneList_L, decreasing = TRUE)

p1_L <- cnetplot(
  edox_L,
  foldChange   = geneList_L,
  categorySize = "pvalue",
  circular     = TRUE,  # ring layout
  colorEdge    = TRUE   # edges colored by category
  # Optionally, add: showCategory = 5, node_label = "gene"
) + ggtitle("Gene Concept Network (A549 L vs P)")

# 4) Create an enrichment map
edox_L <- pairwise_termsim(edox_L)
p2_L <- emapplot(edox_L, layout = "kk") +
  ggtitle("Enrichment Map (A549 L vs P)")

# 5) Combine the cnetplot and emapplot side by side in a PDF
pdf("A549_LvsP_Enrichment_Networks.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_L, p2_L, ncol = 2, labels = LETTERS[1:3], rel_widths = c(.8, .8, 1.2))
dev.off()
```

```{r}
# Filter resSig_L_vs_P for abs(log2FoldChange) > 2
resSig_L_vs_P_filtered <- resSig_L_vs_P[abs(resSig_L_vs_P$log2FoldChange) > 2, ]

# Build a filtered fold-change vector
geneList_L_filtered <- resSig_L_vs_P_filtered$log2FoldChange
names(geneList_L_filtered) <- as.character(resSig_L_vs_P_filtered$entrez)
geneList_L_filtered <- sort(geneList_L_filtered, decreasing = TRUE)

# Now run enrichGO using this filtered gene list:
ego_CC_L_filtered <- enrichGO(
  gene          = names(geneList_L_filtered),
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_L_filtered <- setReadable(ego_CC_L_filtered, 'org.Hs.eg.db', 'ENTREZID')

# Update plots accordingly
p1_L_filtered <- cnetplot(
  edox_L_filtered,
  foldChange   = geneList_L_filtered,
  categorySize = "pvalue",
  circular     = TRUE,
  colorEdge    = TRUE
) + ggtitle("Gene Concept Network (Filtered |A549 L vs P| > 2)")

edox_L_filtered <- pairwise_termsim(edox_L_filtered)
p2_L_filtered <- emapplot(edox_L_filtered, layout = "kk") +
  ggtitle("Enrichment Map (Filtered |A549 L vs P| > 2)")

# Export filtered plots
pdf("A549_LvsP_Enrichment_Networks_filtered.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_L_filtered, p2_L_filtered, ncol = 2, labels = LETTERS[1:3], rel_widths = c(.8, .8, 1.2))
dev.off()
```


3) For AG vs P
```{r}
# Annotate resSig_AG_vs_P with gene symbol, gene name, and ENTREZ ID
resSig_AG_vs_P$symbol <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_AG_vs_P),
                                column = "SYMBOL",
                                keytype = "ENSEMBL",
                                multiVals = "first")

resSig_AG_vs_P$genename <- mapIds(org.Hs.eg.db,
                                  keys = rownames(resSig_AG_vs_P),
                                  column = "GENENAME",
                                  keytype = "ENSEMBL",
                                  multiVals = "first")

resSig_AG_vs_P$entrez <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_AG_vs_P),
                                column = "ENTREZID",
                                keytype = "ENSEMBL",
                                multiVals = "first")

# Build a vector of ENTREZ IDs (remove any NAs)
geneList_AG <- na.omit(resSig_AG_vs_P$entrez)

# Perform GO over-representation analysis (can also be for Cellular Compartiment)
# For Biological Process (BP)
ego_BP_AG <- enrichGO(
  gene          = geneList_AG,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",           # change here for BP
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# For Molecular Function (MF)
ego_MF_AG <- enrichGO(
  gene          = geneList_AG,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "MF",           # change here for MF
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

barplot(ego_BP_AG, showCategory = 20, title = "GO BP Enrichment (A549 AG vs P)")
dotplot(ego_MF_AG, showCategory = 20, title = "GO MF Enrichment (A549 AG vs P)")
```
```{r}
## Enrichment maps

# 1) Convert enrichGO results (ego_AG) to a "readable" object, so gene IDs become symbols

ego_CC_AG <- enrichGO(
  gene          = geneList_AG,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_AG <- setReadable(ego_CC_AG, 'org.Hs.eg.db', 'ENTREZID')

# 2) Build a fold-change vector for your genes
geneList_AG <- resSig_AG_vs_P$log2FoldChange
names(geneList_AG) <- as.character(resSig_AG_vs_P$entrez)
geneList_AG <- sort(geneList_AG, decreasing = TRUE)

p1_AG <- cnetplot(
  edox_AG,
  foldChange   = geneList_AG,
  categorySize = "pvalue",
  circular     = TRUE,  # ring layout
  colorEdge    = TRUE   # edges colored by category
  # showCategory = 5,    # optionally limit the number of categories displayed
  # node_label  = "gene" # optionally label gene nodes with symbols
) + ggtitle("Gene Concept Network (A549 AG vs P)")

# 4) Create an enrichment map
edox_AG <- pairwise_termsim(edox_AG)
p2_AG <- emapplot(edox_AG, layout = "kk") +
  ggtitle("Enrichment Map (A549 AG vs P)")

# 5) Combine the cnetplot and emapplot side by side in a PDF
pdf("A549_AGvsP_Enrichment_Networks.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_AG, p2_AG, ncol = 2, labels = LETTERS[1:3], rel_widths = c(.8, .8, 1.2))
dev.off()
```

```{r}
# Filter resSig_AG_vs_P for abs(log2FoldChange) > 2
resSig_AG_vs_P_filtered <- resSig_AG_vs_P[abs(resSig_AG_vs_P$log2FoldChange) > 2, ]

# Build filtered fold-change vector
geneList_AG_filtered <- resSig_AG_vs_P_filtered$log2FoldChange
names(geneList_AG_filtered) <- as.character(resSig_AG_vs_P_filtered$entrez)
geneList_AG_filtered <- sort(geneList_AG_filtered, decreasing = TRUE)

# Run enrichGO using filtered gene list
ego_CC_AG_filtered <- enrichGO(
  gene          = names(geneList_AG_filtered),
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_AG_filtered <- setReadable(ego_CC_AG_filtered, 'org.Hs.eg.db', 'ENTREZID')

# Create the cnetplot
p1_AG_filtered <- cnetplot(
  edox_AG_filtered,
  foldChange   = geneList_AG_filtered,
  categorySize = "pvalue",
  circular     = TRUE,
  colorEdge    = TRUE
) + ggtitle("Gene Concept Network (Filtered |AG vs P| > 2)")

# Create the enrichment map
edox_AG_filtered <- pairwise_termsim(edox_AG_filtered)
p2_AG_filtered <- emapplot(edox_AG_filtered, layout = "kk") +
  ggtitle("Enrichment Map (Filtered |AG vs P| > 2)")

# Combine plots into PDF
pdf("A549_AGvsP_Enrichment_Networks_filtered.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_AG_filtered, p2_AG_filtered, ncol = 2, labels = LETTERS[1:3], rel_widths = c(.8, .8, 1.2))
dev.off()
```


### For metastatic lines comparison: AG vs L

```{r}
dds_DGE_results_AG_vs_L <- results(
  dds_DGE,
  contrast = c("group", "AG", "L")  
)

head(dds_DGE_results_AG_vs_L)
summary(dds_DGE_results_AG_vs_L)
```

```{r}
# Subset Significant Genes (padj < 0.01) for AG vs L
resSig_AG_vs_L <- subset(dds_DGE_results_AG_vs_L, padj < 0.05)
resSig_AG_vs_L <- resSig_AG_vs_L[order(resSig_AG_vs_L$padj), ]

# Add a 'symbol' column (mapping ENSEMBL to gene SYMBOL)
library(AnnotationDbi)
library(org.Hs.eg.db)

resSig_AG_vs_L$symbol <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(resSig_AG_vs_L),
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
)

head(resSig_AG_vs_L)
```

```{r}
# Strongest Up/Down-Regulated Genes for AG vs L
head(resSig_AG_vs_L[order(resSig_AG_vs_L$log2FoldChange), ])

# Strongest upregulated genes (highest log2 fold change)
head(resSig_AG_vs_L[order(resSig_AG_vs_L$log2FoldChange, decreasing = TRUE), ])

# Export Significant Results
# write.table(
#   resSig_AG_vs_L,
#   file = "A549_padj01_Significant_Results_AG_vs_L.txt",
#   sep = "\t",
#   quote = FALSE,
#   row.names = TRUE
# )
```

```{r}
# Histogram of p-values (AG vs. L)
hist(
  dds_DGE_results_AG_vs_L$pvalue,
  col = "blue",
  border = "white",
  xlab = "",
  ylab = "Frequency",
  breaks = seq(0, 1, 0.05),
  main = "Histogram of p-values (AG vs. L)"
)
```

```{r, warning=FALSE, message=FALSE}
dds$group <- relevel(dds$group, ref = "L")
dds_DGE <- DESeq(dds)
```


```{r,warning=FALSE, message=FALSE}
# MA Plots (Basic and Shrunk)

# 1) Basic MA plot
plotMA(
  dds_DGE_results_AG_vs_L,
  alpha = 0.05,
  main  = "AG vs. L (Basic MA plot)",
  ylim  = c(-5, 5)
)

# 2) Shrunken MA plot using apeglm
res_shrink_AG_vs_L <- lfcShrink(
  dds_DGE,
  coef = "group_AG_vs_L",
  type = "apeglm"
)
plotMA(res_shrink_AG_vs_L, ,
  alpha = 0.05,
  main  = "AG vs. L (Shrunken MA plot)",
  ylim  = c(-5, 5))
```
Volcano Plot Metastatic lines:

```{r, warning=FALSE}

results_order_AG_vs_L <- as.data.frame(dds_DGE_results_AG_vs_L)

results_order_AG_vs_L$symbol <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(results_order_AG_vs_L),
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
)

results_order_AG_vs_L$padj[results_order_AG_vs_L$padj == 0] <- 1e-300

results_order_AG_vs_L$negLog10Padj <- -log10(results_order_AG_vs_L$padj)

results_order_AG_vs_L$Significance <- "Not Sig"
results_order_AG_vs_L$Significance[
  results_order_AG_vs_L$padj < 0.05 & results_order_AG_vs_L$log2FoldChange > 0.38
] <- "Up"
results_order_AG_vs_L$Significance[
  results_order_AG_vs_L$padj < 0.05 & results_order_AG_vs_L$log2FoldChange < -0.38
] <- "Down"


p_AG_vs_L <- ggplot(results_order_AG_vs_L, aes(x = log2FoldChange, y = negLog10Padj)) +
  geom_point(aes(color = Significance), alpha = 0.8, size = 2) +
  scale_color_manual(
    values = c("Down" = "#377EB8", "Not Sig" = "grey70", "Up" = "firebrick")
  ) +
  labs(
    title = "A549 Metastatic Lines: AdrenalGland vs. Bone",
    x = expression(log[2]~fold~change),
    y = expression(-log[10]~(padj))
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title       = element_text(face = "bold", hjust = 0.5),
    panel.grid.minor = element_blank(),
    legend.title     = element_blank()
  )

p_AG_vs_L <- p_AG_vs_L +
  geom_vline(xintercept = c(-0.38, 0.38), color = "blue", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "blue", linetype = "dashed")


topGenes_AG_vs_L <- subset(
  results_order_AG_vs_L,
  padj < 0.05 & abs(log2FoldChange) > 2
)

topGenes_AG_vs_L <- topGenes_AG_vs_L[order(topGenes_AG_vs_L$padj), ]
topGenes20_AG_vs_L <- head(topGenes_AG_vs_L, 20)

p_AG_vs_L <- p_AG_vs_L +
  geom_label_repel(
    data = topGenes20_AG_vs_L,
    aes(label = symbol),
    size = 3,
    color = "black",
    fill = "white",
    box.padding = 0.65,
    point.padding = 0.3,
    force = 15,
    max.overlaps = Inf,
    segment.color = "black"
  )

print(p_AG_vs_L)
```

```{r}
# 1. Subset & sort by padj (AG vs L)
resSig <- subset(dds_DGE_results_AG_vs_L, padj < 0.05)
resSig <- resSig[order(resSig$padj), ]

# 2. Top 20
top20 <- head(resSig, 20)

# 3. Map ENSEMBL → SYMBOL
top20$symbol <- mapIds(org.Hs.eg.db,
                       keys      = rownames(top20),
                       column    = "SYMBOL",
                       keytype   = "ENSEMBL",
                       multiVals = "first")

# 4. Extract VST matrix rows
vsd_mat <- assay(vsd)
mat     <- vsd_mat[rownames(top20), ]

# 5. Swap in gene symbols
rownames(mat) <- top20$symbol

# 6. Keep only L & AG samples
meta    <- as.data.frame(colData(vsd))
keep    <- rownames(meta)[meta$group %in% c("L","AG")]
mat2    <- mat[, keep]

# 7. Center rows (optional)
mat2 <- mat2 - rowMeans(mat2)

# 8. Build annotation df
annotation_col <- data.frame(
  group = meta[keep, "group"],
  row.names = keep
)

# 9. Define the exact column order you want
#    e.g. first all Limb samples, then all AdrenalGland samples
desired_order <- c(
  "AL1","AL2","AL3",      
  "AAG1","AAG2","AAG3"    
)

# 10. Subset & reorder both matrix and annotation
mat2           <- mat2[, desired_order]
annotation_col <- annotation_col[desired_order, , drop = FALSE]

# 11. Color palette
my_colors <- colorRampPalette(rev(brewer.pal(9, "RdBu")))(255)

# 12. Plot without re-clustering the columns
pheatmap(
  mat2,
  annotation_col = annotation_col,
  color          = my_colors,
  cluster_cols   = FALSE,         
  show_rownames  = TRUE,
  main           = "A549 Metastasic Lines AG vs L: Top 20 DEGs"
)
```

```{r}
# Annotate resSig_AG_vs_L with gene symbol, gene name, and ENTREZ ID
resSig_AG_vs_L$symbol <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_AG_vs_L),
                                column = "SYMBOL",
                                keytype = "ENSEMBL",
                                multiVals = "first")

resSig_AG_vs_L$genename <- mapIds(org.Hs.eg.db,
                                  keys = rownames(resSig_AG_vs_L),
                                  column = "GENENAME",
                                  keytype = "ENSEMBL",
                                  multiVals = "first")

resSig_AG_vs_L$entrez <- mapIds(org.Hs.eg.db,
                                keys = rownames(resSig_AG_vs_L),
                                column = "ENTREZID",
                                keytype = "ENSEMBL",
                                multiVals = "first")

# Build a vector of ENTREZ IDs (remove any NAs)
geneList_AG_vs_L <- na.omit(resSig_AG_vs_L$entrez)

# Perform GO over-representation analysis for Biological Process (BP)
ego_BP_AG_vs_L <- enrichGO(
  gene          = geneList_AG_vs_L,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",           # Biological Process
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# For Molecular Function (MF)
ego_MF_AG_vs_L <- enrichGO(
  gene          = geneList_AG_vs_L,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "MF",           # Molecular Function
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# Plot the enrichment results
barplot(ego_BP_AG_vs_L, showCategory = 20, title = "GO BP Enrichment (A549 Met AG vs L)")
dotplot(ego_MF_AG_vs_L, showCategory = 20, title = "GO MF Enrichment (A549 Met AG vs L)")
```
```{r}
## Enrichment maps

# 1) Convert enrichGO results for Cellular Component (CC) to a "readable" object
ego_CC_AG_vs_L <- enrichGO(
  gene          = geneList_AG_vs_L,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",           # Cellular Component
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_AG_vs_L <- setReadable(ego_CC_AG_vs_L, 'org.Hs.eg.db', 'ENTREZID')

# 2) Build a fold-change vector for your genes
geneList_fc_AG_vs_L <- resSig_AG_vs_L$log2FoldChange
names(geneList_fc_AG_vs_L) <- as.character(resSig_AG_vs_L$entrez)
geneList_fc_AG_vs_L <- sort(geneList_fc_AG_vs_L, decreasing = TRUE)

# 3) Create a Gene Concept Network plot (cnetplot)
p1_AG_vs_L <- cnetplot(
  edox_AG_vs_L,
  foldChange   = geneList_fc_AG_vs_L,
  categorySize = "pvalue",
  circular     = TRUE,  # ring layout
  colorEdge    = TRUE   # edges colored by category
  # Optionally, you can restrict the number of categories displayed or label nodes
) + ggtitle("Gene Concept Network (A549 Met AG vs L)")

# 4) Create an enrichment map
edox_AG_vs_L <- pairwise_termsim(edox_AG_vs_L)
p2_AG_vs_L <- emapplot(edox_AG_vs_L, layout = "kk") +
  ggtitle("Enrichment Map (A549 Met AG vs L)")

# 5) Combine the cnetplot and emapplot side by side in a PDF
pdf("A549_MET_AGvsL_Enrichment_Networks.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_AG_vs_L, p2_AG_vs_L, ncol = 2, labels = LETTERS[1:3], 
                   rel_widths = c(.8, .8, 1.2))
dev.off()
```

```{r}
# Filter resSig_AG_vs_L for abs(log2FoldChange) > 2
resSig_AG_vs_L_filtered <- resSig_AG_vs_L[abs(resSig_AG_vs_L$log2FoldChange) > 2, ]

# Build filtered fold-change vector
geneList_fc_AG_vs_L_filtered <- resSig_AG_vs_L_filtered$log2FoldChange
names(geneList_fc_AG_vs_L_filtered) <- as.character(resSig_AG_vs_L_filtered$entrez)
geneList_fc_AG_vs_L_filtered <- sort(geneList_fc_AG_vs_L_filtered, decreasing = TRUE)

# Run enrichGO using filtered gene list
ego_CC_AG_vs_L_filtered <- enrichGO(
  gene          = names(geneList_fc_AG_vs_L_filtered),
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "CC",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.01,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

edox_AG_vs_L_filtered <- setReadable(ego_CC_AG_vs_L_filtered, 'org.Hs.eg.db', 'ENTREZID')

# Create the cnetplot
p1_AG_vs_L_filtered <- cnetplot(
  edox_AG_vs_L_filtered,
  foldChange   = geneList_fc_AG_vs_L_filtered,
  categorySize = "pvalue",
  circular     = TRUE,
  colorEdge    = TRUE
) + ggtitle("Gene Concept Network (Filtered |AG vs L| > 2)")

# Create the enrichment map
edox_AG_vs_L_filtered <- pairwise_termsim(edox_AG_vs_L_filtered)
p2_AG_vs_L_filtered <- emapplot(edox_AG_vs_L_filtered, layout = "kk") +
  ggtitle("Enrichment Map (Filtered |AG vs L| > 2)")

# Combine plots into PDF
pdf("A549_MET_AGvsL_Enrichment_Networks_filtered.pdf", width = 25, height = 10)
cowplot::plot_grid(p1_AG_vs_L_filtered, p2_AG_vs_L_filtered, ncol = 2, labels = LETTERS[1:3], 
                   rel_widths = c(.8, .8, 1.2))
dev.off()
```


Heatmap with kmeans

```{r}
# Get the union of gene IDs from all contrasts
top_gene_ids <- unique(c(rownames(topGenes_CTC), rownames(topGenes_L), rownames(topGenes_AG), rownames(topGenes_AG_vs_L)))
top_gene_ids <- top_gene_ids[!is.na(top_gene_ids)]
```

```{r}
common_ids <- intersect(top_gene_ids, rownames(vsd_norm_counts))
length(common_ids)
```

```{r}
vsd_mat_subset <- vsd_norm_counts[common_ids, ]
# This step normalizes each gene’s values across samples to mean=0, sd=1, so that clustering focuses on expression patterns rather than magnitude.
vsd_mat_subset_scaled <- t(scale(t(vsd_mat_subset)))
# Remove rows that become NA (e.g., zero variance)
vsd_mat_subset_scaled <- vsd_mat_subset_scaled[complete.cases(vsd_mat_subset_scaled), ]
```

```{r}
# k-means Clustering
k <- 4 # choose how many clusters (k) you want to group your genes into
kmeans_result <- kmeans(vsd_mat_subset_scaled, centers = k)
# Extract the cluster assignments (which cluster each gene belongs to)
clusters <- kmeans_result$cluster
```

```{r}
# Reorder Rows by Cluster for Heatmap: groups genes by their assigned cluster in the final heatmap
gene_order <- order(clusters)
vsd_mat_subset_scaled <- vsd_mat_subset_scaled[gene_order, ]
clusters_ordered <- clusters[gene_order]
# Create Row Annotation to Show Cluster Membership
row_annot <- data.frame(Cluster = factor(clusters_ordered))
rownames(row_annot) <- rownames(vsd_mat_subset_scaled)
```

```{r}
my_colors <- colorRampPalette(c("green", "black", "red"))(100)
# Plot the Heatmap
pheatmap(
  vsd_mat_subset_scaled,
  cluster_rows = FALSE,         # preserve k-means ordering
  cluster_cols = TRUE,          # cluster the samples
  show_rownames = FALSE,        # often too many genes to display
  annotation_row = row_annot,   # shows cluster membership
  scale = "none",               # already scaled the data
  color = my_colors,            # custom color palette
  main = "A549 K-means Heatmap (VST)"
)
```
Study each cluster
```{r}
library(ggplot2)
library(clusterProfiler)
library(org.Hs.eg.db)  
library(reshape2)
```

```{r}
# Create an output folder for plots if it doesn't already exist
if (!dir.exists("output_plots")) {
  dir.create("output_plots")
}

# Extract Gene Lists by Cluster
cluster_list <- split(rownames(vsd_mat_subset_scaled), clusters)  # 'clusters' is a named vector with cluster assignments

for (clust in names(cluster_list)) {
  
  # Extract Gene List
  gene_list <- cluster_list[[clust]]
  cat("Cluster", clust, "contains", length(gene_list), "genes\n")
  
  write.table(gene_list, file = paste0("A549_Cluster_", clust, "_genes.txt"), 
              quote = FALSE, row.names = FALSE, col.names = FALSE)
  
  # Extract the expression matrix for genes in this cluster
  cluster_expr <- vsd_mat_subset_scaled[gene_list, ]
  
  # Compute the average expression for each sample across these genes
  avg_expr <- colMeans(cluster_expr)
  
  # Create a data frame for plotting
  plot_df <- data.frame(Sample = colnames(cluster_expr), 
                        Expression = avg_expr)
  
  # Optionally, order samples if needed (e.g., factor levels)
  plot_df$Sample <- factor(plot_df$Sample, levels = colnames(cluster_expr))
  
  # Plot the average expression as a line plot using ggplot2
  p <- ggplot(plot_df, aes(x = Sample, y = Expression, group = 1)) +
    geom_line(color = "blue") +
    geom_point(color = "red", size = 2) +
    ggtitle(paste("Average Expression Profile for Cluster", clust)) +
    xlab("Samples") + ylab("Average VST Expression") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # Save the plot to a file using png() device
  png(filename = paste0("output_plots/A549_Cluster_", clust, "_profile.png"),
      width = 800, height = 600)
  print(p)
  dev.off()
  
  # Functional Analysis using clusterProfiler
  # Convert Ensembl IDs to Entrez IDs using bitr (adjust keyType if needed)
  eg <- bitr(gene_list, fromType = "ENSEMBL", 
             toType = "ENTREZID", OrgDb = org.Hs.eg.db)
  
  # Check if conversion returned any results
  if (nrow(eg) > 0) {
    # Perform Gene Ontology (GO) enrichment analysis for Biological Process (BP)
    ego <- enrichGO(gene         = eg$ENTREZID,
                    OrgDb        = org.Hs.eg.db,
                    keyType      = "ENTREZID",
                    ont          = "BP",
                    pAdjustMethod = "BH",
                    qvalueCutoff = 0.05,
                    readable     = TRUE)
    
    # Print top enriched GO terms (if any)
    cat("GO enrichment results for Cluster", clust, ":\n")
    print(head(ego))
    
    # Plot a dotplot of enriched GO terms (showing top 10)
    dp <- dotplot(ego, showCategory = 10) + 
      ggtitle(paste("GO Enrichment for Cluster", clust))
    
    # Save the dotplot as well
    png(filename = paste0("output_plots/A549_Cluster_", clust, "_GO_enrichment.png"),
        width = 800, height = 600)
    print(dp)
    dev.off()
    
  } else {
    cat("No Entrez ID mapping found for genes in Cluster", clust, "\n")
  }
  
  cat("---------------------------------------------------------\n")
}
  
```

```{r}
devtools::session_info()
```





